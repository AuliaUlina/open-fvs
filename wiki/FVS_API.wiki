#summary FVS-API: Running FVS as a Shared Library (*work in progress*)

Nick Crookston, January 2012

= Contents =

<wiki:toc max_depth="2" />

= Introduction =

This document describes the FVS _Application Program Interface_ (API) that provides for running FVS as a _shared library_.

Note that the fact that FVS is written as a _procedural_ program rather than an _object oriented_ program means that the methods used in the FVS_API are not consistent with an object-oriented paradigm. Specific goals, for example, processing many stands in parallel through time, are achieved differently in FVS than would be accomplished if FVS were object oriented. The design of the API is keyed to this reality.

The design of this API is driven by known and perceived needs and as those change, the API will change. The design was further dictated by the system used to call it. So far, that is only one system, the [http://www.r-project.org/ R System for Statistical Computing]. However, I know that [http://essa.com/ Don Robinson and Sarah Beukema] are targeting a system based on .Net and another programmer is working on calling FVS from Python. As these efforts progress, it is highly likely that the API will be augmented.

Speaking of R, there is a directory to this repository called _rFVS_. This is a collection of R functions used to run FVS on a wide variety of simulations. These functions also serve to demonstrate how to use the API that is described below. In the future, these R functions may become an R package; for now they documented in the [rFVS rFVS Wiki page].

= Basic Idea =

FVS can hold one stand in memory at a time. When a shared library is loaded, the state of its memory is not set to reliable initial values; no stand, no run options, and no trees are defined. Using the current API functions, there is only one way to define the initial conditions and that is to read a keyword file as would be done with FVS if it were run as a program rather than as a shared library. FVS keyword commands that cause FVS to read site and tree information are used to setup the simulation.

Specifying the name of the keyword file is done by setting the `--keywordfile` argument as done the [FVSCommandLine FVS Command Line] (there is an [FVS_API#Command_Line API call] to set this value without putting it on the command line). The FVS program is then run by calling a single API function which returns when the simulation is over, unless, of course, the program is requested to stop during the simulation. The request to stop is done by setting a stop point and stop year. The program returns when it reaches the designated stop point and then it picks up the calculations were it left off when it is called again. There are several ways to interact with the program between its "return" and when it is called again, each is supported with an API function. Note, this is the _basic idea_, details are provided below that cover more complicated scenarios.

= API Reference =

What follows is the definition of subroutines designed to be called by the parent programs. On some operating systems, depending on how the FVS library is built, many routines within FVS besides those listed below could be called. It would be easy to distroy the the simulation if FVS routines are called out of order. User's are encouraged to take a minimalist approach, yet by all means do take an approach!

== Command Line ==

{{{
subroutne fvsSetCmdLine(theCmdLine,lenCL,rtnCode)
}}}

Set the command line arguments. When FVS is run as a program, this value is specified on the command line as arguments to the program start (see [FVSCommandLine FVS Command Line] for definitions of this string). Values specified using this function take precedence over those set on the actual command line. This function also opens files for input as indicted by the values found and it can result in the FVS [FVS_API#Return_Code_State return code state] to be reset.


||Argument||Definition||
||`theCmdLine`||input character string defines the command line values.||
||`lenCL`||the length of _theCmdLine_ (integer)||
||`rtnCode`||current FVS return code (integer)||


== FVS File Close ==

{{{
subroutine fvsCloseFile(filename,nch)
}}}

Close the file if it is opened. This routine will normally not be needed.

||Argument||Definition||
||`filename`||input character string specifying a file name.||
||`nch`||the length of the defined part of _filename_ (integer)||


== Stop Points ==

{{{
subroutine fvsSetStoppointCodes (spptcd,spptyr)
subroutine fvsGetStoppointCodes (spptcd,spptyr)
}}}

Set (or Get) the parameters that control start/restart while FVS is run as a shared library (also see [FVSCommandLine FVS Command Line] for definitions).

||Argument||Definition||
||`stptcd`||is the stop point code (integer) to be used, see table below for codes||
||`stptyr`||is the stop point year (integer) be used: 0 mean never stop, -1 means stop at every cycle.||

||Stop Point Codes||Definition||
||`0`||Never stop.||
||`-1`||Stop at every stop location.||
||`1`||Stop just before the first call to the Event Monitor.||
||`2`||Stop just after the first call to the Event Monitor.||
||`3`||Stop just before the second call to the Event Monitor.||
||`4`||Stop just after the second call to the Event Monitor.||
||`5`||Stop after growth and mortality has been computed, but prior to applying them.||
||`6`||Stop just before the estab routines are called.||

{{{
subroutine fvsGetRestartcode (restartcode)
}}}

Returns the current value of the stop/restart code. This is an integer the indicates point within the FVS sequence of calculations were the program will start when subroutine fvs is called next (also see [FVSCommandLine FVS Command Line]. Values are as follows:

||Stop Point Code||Definition||
||`1`||Stop was done just before the first call to the Event Monitor.||
||`2`||Stop was done just after the first call to the Event Monitor.||
||`3`||Stop was done just before the second call to the Event Monitor.||
||`4`||Stop was done just after the second call to the Event Monitor.||
||`5`||Stop was done after growth and mortality has been computed, but prior to applying them.||
||`6`||Stop was done just before the estab routines are called.||


== Return Code State ==

{{{
subroutine fvsGetRtnCode (rtnCode)
subroutine fvsSetRtnCode (rtnCode)
}}}

fvsGetRtnCode simply returns the current value of the return code while fvsSetRtnCode sets it as well. If fvsSetRtnCode is called with a non-zero value, FVS automatically closes all open files and any open databases.

_rtnCode_ is returned with the current return code value in FVS.
||Value||Meaning||
||`-1`||indicates that FVS has not been started.||
||`0`||indicates that FVS is in good running state.||
||`1`||indicates that FVS has detected an error of some kind and should not be used until reset by specifying new input.||
||`2`||indicates that FVS has finished processing all the stands; new input can be specified.||

== FVS ==

{{{
subroutine fvs(rtnCode)
}}}

Run FVS up to the next stop point, or to the end of the simulation. Start by reading the keyword file or by reading a restart file, depending on run options [see FVSCommandLine FVS Command Line].

The _rtnCode_ is as described for [FVS_API#Return_Code_State Return Code State].

== FVS Dimensions ==

{{{
subroutine fvsDimSizes(ntrees,ncycles,maxtrees,maxspecies,
                       maxplots,maxcycles)
}}}

Get dimension information for the version of FVS being run.

||Argument||Definition||
||`ntrees`||returned number of trees defined in FVS.||
||`ncycles`||returned number of cycle defined in FVS.||
||`nplots`||returned number of plots inventoried.||
||`maxtrees`||returned maximum number of trees FVS can hold.||
||`maxspecies`||returned maximum number of species FVS has defined.||
||`maxplots`||returned maximum number of sample plots FVS can hold.||
||`maxcycles`||returned maximum number of cycles the can be defined in FVS.||

== FVS Stand Visualizaton (SVS) Dimensions ==

{{{
subroutine fvsSVSDimSizes(nsvsobjs, ndeadobjs, ncwdobjs,  mxsvsobjs, 
                          mxdeadobjs, mxcwdobjs)
}}}

Get dimension information for the version of FVS being run.

||Argument||Definition||
||`nsvsobjs`||returned number of tota objects defined in SVS storage.||
||`ndeadobjs`||returned number of dead tree objects defined in SVS storage.||
||`ncwdobjs`||returned number of course wood objects defined in SVS storage.||
||`mxsvsobjs`||returned maximum number of live tree objects SVS can hold.||
||`mxdeadobjs`||returned maximum number of dead tree objects SVS can hold.||
||`mxcwdobjs`||returned maximum number of course wood objects SVS can hold.||


== FVS Summary Statistics ==

{{{
subroutine fvsSummary(summary,icycle,ncycle,maxrow,maxcol,rtnCode)
}}}

Get a snap shot of the simulation of the current stand. (The return code reported here are independent of the general return code.)

||Argument||Definition||
||`summary`||returned vector of 20 integer words that hold summary statistic attributes.||
||`icycle`||requested cycle number corresponding to the summary statistics desired.||
||`ncycle`||returned number of cycles defined for the run.||
||`maxrow`||returned maximum value of ncycle (and icycle).||
||`maxcol`||returned length of summary (20 words).||
||`rtnCode`||returned status code for this call where 0=OK, 1=an error.||

The 20 values are as follows (in western variants, eastern variants differ, (see [http://www.fs.fed.us/fmsc/fvs/documents/index.shtml FVS documentation] for more details).

||Name||Definition||
||`Year`||Current year of simulation||
||`Age`||Current age of stand||
||`Tpa`||Trees per acre||
||`TCuFt`||Total cubic volume||
||`MCuFt`||Total merchantable volume||
||`BdFt`||Total Board Foot Volume||
||`RTpa`||Removed trees per acre||
||`RTCuFt`||Removed total cubic volume||
||`RMCuFt`||Removed merchantable volume||
||`RBdFt`||Removed board foot volume||
||`ATBA`||After thin basal area||
||`ATCCF`||After thin CCF||
||`ATTopHt`||After thin top height||
||`PrdLen`||Length of simulation cycle (years)||
||`Acc`||Accretion in cubic feet/acre/year||
||`Mort`||Mortality in cubic feet/acre/year||
||`SampWt`||Stand sampling weight, often the area||
||`ForTyp`||Forest type code||
||`SizeCls`||Size class code||
||`StkCls`||Stocking class code||

_TODO:_ Document the list for the eastern variants.

== FVS Tree Attributes ==

{{{
subroutine fvsTreeAttr(name,nch,action,ntrees,attr,rtnCode)
}}}

Get or set attributes of the trees in the simulation. (The return code reported here are independent of the general return code.)

||Argument||Definition||
||`name`||character string defining the tree attribute being being acted upon. ||
||`nch`||integer number defining the length of _name_.||
||`action`||action requested where, "get" signals that the current values defined in FVS should be returned as a vector in _attr_ and "set" signals that the current values in FVS should be changed to those specified in _attr_.||
||`ntrees`|| the length of the _attr_||
||`attr`||a vector of double precision (8-byte floats) of the attribute being processed.||
||`rtnCode`||return codes, as follows: 0=OK, 1=_name_ not found, 2=_ntrees_ is greater than the maximum allowed, and 3=there were more or fewer trees the ntrees.||


== FVS Event Monitor Variables ==

{{{
subroutine fvsEvmonAttr(name,nch,action,attr,rtnCode)
}}}

Get or set FVS Event Monitor variables. There are too many variables to list here, see [http://www.fs.fed.us/fmsc/fvs/documents/index.shtml FVS documentation] for more details. (The return code reported here are independent of the general return code.)

||Argument||Definition||
||`name`||character string defining name of the Event Monitor attribute being being acted upon.||
||`nch`||integer number defining the length of _name_.||
||`action`||action requested where, "get" signals that the current values defined in FVS should be returned as a vector in _attr_ and "set" signals that the current values in FVS should be changed to those specified in _attr_.||
||`attr`||a single double precision (8-byte float) word of the attribute being processed.||
||`rtnCode`||return codes, as follows: 0=OK, 1=_name_ not found.||


== Add Trees ==

{{{
subroutine fvsAddTrees(in_dbh,in_species,in_ht,in_cratio,
                       in_plot,in_tpa,ntrees,rtnCode)
}}}

Add more trees to a current simulation. All values are double precision vectors of length _ntrees_ except as noted below. (The return code reported here are independent of the general return code.)

||Argument||Definition||
||`in_dbh`||dbh values for the additional trees.||
||`in_species`||internal FVS species codes for the additional trees.||
||`in_ht`||tree heights for the additional trees.||
||`in_cratio`||crown ratios for the additional trees.||
||`in_plot`||internal FVS plot indicies for the additional trees.||
||`in_tpa`||number of trees per acre like the tree being added.||
||`ntrees`||a integer value, length of the vectors.||
||`rtnCode`||return code, where 0=OK, 1=there was not enough room to store the new trees.||


== Species Codes ==

{{{
subroutine fvsSpeciesCode(fvs_code,fia_code,plant_code,
                          indx,nchfvs,nchfia,nchplant,rtnCode)
}}}

Get the FVS species codes.  (The return code reported here are independent of the general return code.)


||Argument||Definition||
||`fvs_code`||returned FVS species code; 4 chars maximum.||
||`fia_code`||returned FIA code; 4 chars maximum||
||`plant_code`||returned FIA code; 6 chars maximum||
||`indx`||index (integer) of requested code.||
||`nchfvs`||returned actual length of fvs_code (integer).||
||`nchfia`||returned actual length of fia_code (integer).||
||`nchplant`||returned actual length of plant_code (integer).||
||`rtnCode`||return code, where 0=OK, 1=_indx_ is out of range.||


== Define Harvest ==

{{{
subroutine fvsCutTrees(pToCut,nt,rtnCode)
}}}


_TODO:_ Not yet implemented

Specify the proportion of each existing tree record FVS should cut. (The return code reported here are independent of the general return code.)

||Argument||Definition||
||`pToCut`||double precision vector of proportions, one per tree.||
||`ntrees`||length of pToCut (integer)||
||`rtnCode`||return code, where 0=OK, 1=_ntrees_ is not equal to the number of trees in the model.||


== Stand Identification ==

{{{
subroutine fvsStandID(sID,sCN,mID,ncsID,ncCN,ncmID)
}}}

Get the stand identification codes.

||Argument||Definition||
||`sID`||returned character string holding the stand identification code (26 characters maximum).||
||`sCN`||returned character string holding the database control identification (40 characters maximum).||
||`mID`||returned character string holding the management identification code (4 characters maximum).||
||`ncsID`||length of defined part of _sID_ (integer)||
||`ncCN`||length of the defined part of _sCN_ (integer) ||
||`ncmID`||length of defined part of _mID_ (integer)||


== Current Keyword File Name ==

{{{
subroutine fvsGetKeywordFileName(name,mxch,nch)
}}}

Get the string that hold the current file name (not NULL terminated).

||Argument||Definition||
||`name`||returned character string holding the file name.||
||`mxch`||the length of the string the calling routine has reserved (integer)||
||`nch`||returned length of defined part of _name_ (integer)||

== Return Error Code ==

{{{
subroutine fvsGetICCode(rtnCode)
}}}

Fetch the integer code returned when FVS exits. A value of 0 means that no serious errors occurred. Non-zero values indicate different error states that sometimes make it impossible to continue (error codes: 10=input data; 20=keyword or expression; 30=extension or group activities; 40=scratch file). The maximum error code value is returned, with more specific clues are written to the main output file beginning with "FVS<i>nn</i> WARNING", where <i>nn</i> =(01,...,36)

||Argument||Definition||
||`rtnCode`||value of FVS return code (integer)||

== Summary of TODO ==

Here is a list of TODO items:

  # Finish the fvsCutTrees function.
  # Set up the fvs function so that one can restart from the previous stand (assuming that the stand is stored in a stoppoint file. This would allow for making several projections from a stoppoint year into the future (upto a stoppoint year) for the same stand. This feature would be useful for treatment optimizations. There are two functions in the _API_ that are designed to support the functionality, but they have not yet been tested.
  # Add a --treeDataFile option to the command line.