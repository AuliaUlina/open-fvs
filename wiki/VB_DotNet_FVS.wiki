#summary Running FVS from VB.Net

=Running FVS from VB.Net using the API=

_Don Robinson, [http://www.essa.com ESSA] Technologies, November 2014_

This Wiki page documents the key concepts for writing VB.Net code, so that .Net developers can create 32-bit applications that use FVS through the API (see [FVS_API]). The example repository code is still under development with 18 of 22 API calls ('Methods') built and tested. These methods provide good templates for the completion of the interface, and new participants and developers are welcome.

Depending on the tool chain and variant name, there are small differences in the names of FVS DLLs and names of the API calls, respectively. These differences are very minor, and the sample code and instructions should make it clear how to adapt to any combination of tool chain and variant. The example which is provided is specific to the BC variant built with Visual Studio (see [BuildProcess_VisualStudio]), which is targeted for integration with the [http://www.essa.com/telsa TELSA] model.

= Contents =

<wiki:toc max_depth="3" />

==Getting the Source Files==
There are 5 main files in the repository example. You may need to download this code first, as described in [DownloadingSourceCode]. Relative to the root of the SVN repository, the home directory of the example files and directories listed below is *`.\VB.Net-FVS`*.

|| *Filename* || *Purpose* || 
|| .\FVS\FVS.sln || The VS2010 Solution file which implements the Class and Methods described on this Wiki page and demonstrates their use with the FVS-BC variant. ||
|| .\FVS\FVS_API.vb || Class declarations, Constants, Definitions, Properties and Methods which are the basis for all the higher level VB code. ||
|| .\FVS\FVS_Signatures.vb || Declarations for all the API calls. The declarations in this file use the explicit name of the main FVS-BC variant DLL (`FVS_bcc.dll`). As currently written, this name will need to be modified for whichever variant is being used. The file also has declarations of the VB data type for each argument of the lower level call to the API, conforming to the data types of the arguments of the lower level API (see [FVS_API]). Depending on the data type and dimension, arguments may be passed by `ByReference`or `ByValue`. Argument lists that include character strings contain an additional 'Ansi' declaration. ||
|| .\Example\Example.vb || A working example of VB code which runs FVS.||
|| .\Example\bin\Debug || This subdirectory contains the FVS-BC variant DLLs which are called through the API (`FVS_bcc.dll, FVSfofem.dll` and `FVSsql.dll`). It also contains the keyword and Access database files used in the working example, and is the location to which temporary and permanent output files are written during the simulation. All FVS DLLs created by the VS2010 build chain must be manually copied to this directory for the simulation to run. If you wish to code-walk into FVS Fortran/C/C++ code from within the VB application, the corresponding PDB (Program Data Base) files created by VS2010 during a *Debug* compile, must also be copied here. Lastly, the [BuildProcess_VisualStudio#Redistributables redistributable] DLLs must be accessible either by their presence in this directory, or through reference via the $PATH environment variable. ||

The repository contains other (undocumented) files and directories which are necessary to the VS2010 solution, but which are not altered by the developer. You can find more information about the project under the Code Sample section of this Wiki page.

==The FVS_API Class==
Class definitions are located in the file `FVS_API.vb`.

===Declarations===
There is a single private String variable `MeasurementType` used to specify whether input and output should be in imperial or metric units. The default value is "imperial" (e.g. DBH in inches), but this can be changed using a `Property` procedure described below.

===Constructor===
The `New()` constructor sets the default value for `MeasurementType` when a member of the FVS_API class is declared.

===Constants===
This code region encapsulates the constants used for metric/imperial unit conversion (e.g. `INtoCM`). If needed, additional constants can be borrowed from `/open-fvs/trunk/common/METRIC.F77` and implemented here. Seven constants are used so far.

===Properties===
The `MeasurementType` property allows input and output units to be converted between imperial units (the default) and metric units. Internally FVS almost always uses imperial units for its submodels and calculations. Metric unts can be set by code like this (from `Example.vb`):

{{{
fvs.MeasurementUnits = "metric"
}}}

And the current unit-type can be discovered by code like this (from `FVS_API.vb`):

{{{
If (Me.MeasurementUnits = "metric") Then
  S(2) = CInt(S(2) / ACRtoHA)
End If
}}}

===Methods===
Each API call is mirrored by a corresponding VB method, usually removing the prefix "`FVS`" from the API name. The middle column in the table below show the API name created by VS2010. These names differ from the names assigned by the other build chains. For example, DLLs built by MinGW (using gfortran) create APIs with lower case names followed by an *underscore* (e.g. `fvsdimsizes_`). The example Solution and code have not been tested using DLLs created by non-VS2010 builds. For details on the the FVS API arguments, see [FVS_API]. For details on the arguments required by the VB methods, see the project code.

||    || *VB Method Name* || *FVS API Name* || *Notes* ||
||  1 || `DimSizes` || `FVSDIMSIZES` || ||
||  2 || `SVSDimSizes`|| `FVSSVSDIMSIZES` ||  ||
||  3 || `SetCmdLine` || `FVSSETCMDLINE` || ||
||  4 || `RunFVS` || `FVS` || Note different names ||
||  5 || `GetRtnCode` || `FVSGETRTNCODE` || ||
||  6 || `CloseFile` || `FVSCLOSEFILE` || ||
||  7 || `StandID` || `FVSSTANDID` || ||
||  8 || `GetKeywordFilename` || `FVSGETKEYWORDFILENAME` || embedded blanks may cause trouble ||
||  9 || `GetICCode` || `FVSGETICCODE` || ||
|| 10 || `SetRtnCode` || `FVSSETRTNCODE` || ||
|| 11 || `GetRestartCode` || `FVSGETRESTARTCODE` || ||
|| 12|| `SetStopPointCodes` || `FVSSETSTOPPOINTCODES` || ||
|| 13 || `GetStopPointCodes` || `FVSGETSTOPPOINTCODES` || ||
|| 14 || `SpeciesCode` || `FVSSPECIESCODE` || ||
|| 15 || `Summary` || `FVSSUMMARY` || *metric* available ||
|| 16 || `TreeAttr` || `FVSTREEATTR` || *metric* available ||
|| 17 || `SpeciesAttr` || `FVSSPECIESATTR` || not yet implemented ||
|| 18 || `FFEAttrs` || `FVSFFEATTRS` || ||
|| 19 || `AddTrees` || `FVSADDTREES` || *metric* available||
|| 20 || `AddActivity` || `FVSADDACTIVITY` || not yet implemented ||
|| 21 || `CutTrees` || `FVSCUTTREES` || not yet implemented ||
|| 22 || `EvmonAttr` || `FVSEVMONATTR` || *metric* started ||
|| 23 || `SVSObjData` || `FVSSVSOBJDATA` || not yet implemented ||

==Annotated Code Sample==
The Solution in the repository contains two projects: `FVS` and `Example`. The `FVS` project contains the VB code (i.e., `FVS_API.vb` and `FVS_Signatures.vb`) required to call FVS and also defines the `FVS` namespace which is used by the `Example` project to access all the methods.

Developers are reminded that by default, arrays created in VB begin at 0; while those created in Fortran begin at 1 by default. (Although changing the VB default is an option, that has not been done so far.) When you wish to create an array of 20 integers, the VB declaration is:

{{{
Dim Summry(19) As Integer
}}}

This helps to explain the (at first) unusual-looking code:

{{{
Dim Diam(nTrees - 1) As Double
}}}

to create an array of Doubles that upon return from FVS will hold the diameters of all the trees in a treelist with `nTrees` elements.

The following code sample is borrowed from `Example.vb`. The first code snip links the FVS assembly and namespace (which are part of the `FVS` project) to the `Example` project and allows objects of the Class `FVS_API` to be created.

{{{
Imports FVS
}}}

In the next section an `fvs` object is created (along with any other variables necessary to your code) to allow you to write code employing the Methods and Properties of `FVS_API`, ultimately linking to FVS through the API.

{{{
Dim fvs As New FVS_API
}}}

This sets up the simulation to use metric I/O, fetches some array limits 
and finally fetches some species labels (pardon the unusual coloring...)

{{{
'" Units will be metric for Summary and other I/O calls" 
fvs.MeasurementUnits = "metric"

'" Get some basic FVS array sizes prior to running" 
fvs.DimSizes(nTrees, nCycles, nPlots, MaxTrees, MaxSpecies, MaxPlots, MaxCycles)

'" Get the 3 kinds of species labels" 
For i = 1 To MaxSpecies
  fvs.SpeciesCode(FVSCode, FIACode, PlantCode, i, ReturnCode)
Next i

}}}

Next, set the command line and run FVS for the indicated keyword file (containing 2 stands), stopping at 2020.

{{{

'" Set the command line and stopping point"
fvs.SetCmdLine("--keywordfile=MgmtBC.key --stoppoint=1,2020,test.stop", ReturnCode)

'" Run loop of stand and Inspect the current summary table at Cycle 2.
'  Fetch some treelist variables for one of the stands
'  Modify that stand by reducing trees/hectare by 10%."
Do
  fvs.StandID(StandID, CNID, mID)
  fvs.GetKeywordFilename(KeywordFilename)

  '" iterate through the stand(s) in the key file; 2 calls needed" 
  fvs.RunFVS(ReturnCode)
  fvs.RunFVS(ReturnCode)

  '" inspect the error code"
  fvs.GetICCode(RC)
  '" fetch the 'Scen2' stand summary table for Cycle 2"
  '" get some attributes and do simple manipulation of the treelist."
  If (StandID = "Scen2") Then
    iCycle = 2
    fvs.Summary(Summry, iCycle, nCycles, MaxRow, MaxCol, RC)
    fvs.DimSizes(nTrees, nCycles, nPlots, MaxTrees, MaxSpecies, MaxPlots, MaxCycles)

    Dim Diam(nTrees - 1) As Double
    Dim TPH(nTrees - 1) As Double
    Dim Vol(nTrees - 1) As Double
    fvs.TreeAttr("dbh", "get", nTrees, Diam, RC)
    fvs.TreeAttr("tpa", "get", nTrees, TPH, RC)
    fvs.TreeAttr("tcuft", "get", nTrees, Vol, RC)

    Dim Cls5Yrs(MaxSpecies - 1) As Double
    fvs.FFEAttrs("fallyrs5", "get", MaxSpecies, Cls5Yrs, RC)

    "' reduce TPH by 10%"
    For i = 0 To nTrees - 1
      TPH(i) *= 0.9D
    Next i
    fvs.TreeAttr("tpa", "set", nTrees, TPH, RC)

    ' add two new tree records; note types are all double
    ' units here are metric
    nTrees = 2
    Dim DBH(nTrees - 1) As Double
    Dim SPP(nTrees - 1) As Double
    Dim HT(nTrees - 1) As Double
    Dim CRWNRAT(nTrees - 1) As Double
    Dim PLOT(nTrees - 1) As Double
    Dim TPA(nTrees - 1) As Double
    DBH(0) = 12.5
    DBH(1) = 23.0
    SPP(0) = 3
    SPP(1) = 3
    HT(0) = 14.0
    HT(1) = 25.5
    CRWNRAT(0) = 75
    CRWNRAT(1) = 55
    PLOT(0) = 1
    PLOT(1) = 1
    TPA(0) = 150
    TPA(1) = 115
    fvs.AddTrees(DBH, SPP, HT, CRWNRAT, PLOT, TPA, nTrees, RC)
    ' check that new trees have been added
    fvs.DimSizes(nTrees, nCycles, nPlots, MaxTrees, MaxSpecies,MaxPlots, MaxCycles)

    End If
Loop Until ReturnCode <> 0

}}}

Finally, restart FVS and run to the end of the simulation

{{{

fvs.SetCmdLine("--restart=test.stop", ReturnCode)
Do
  fvs.RunFVS(ReturnCode)
Loop Until ReturnCode <> 0

}}}

==Next Steps for Extending FVS with VB.Net==
Here are some high-level tasks that remain:

  * create and test the remaining not-yet-implemented VB Methods; some of these will require a lot of work to implement in metric form, due to the large number of possible events.
  * investigate options to provide interfaces that are compiler independent, so that API calls work for both these forms: `FVSDIMSIZES` and `fvsdimsizes_`.
  * investigate options to create tools that work across all variants, without the annoyance of having to recode the name of the target DLL based on variant and tool chain.
  * develop capability to use full 64-bit FVS builds with 64-bit VB.Net applications. Conversion of the example project to 64-bit capability can be done through update of .Net assemblies from Version 2 to Version 4, but there are heap-corruption problems associated with some API calls.

In addition, there are possible improvements to the Methods that might make them more intuitive and useful. For example, loop-oriented Methods like `SpeciesCode` could be rewritten to fetch all species labels at once by moving the loop inside the Method. Improvements to argument checking is also possible.